---
description: 
globs: 
alwaysApply: true
---
# NineBoxView - 開發與迭代計畫

本檔案旨在指導 NineBoxView 外掛的逐步完善和問題修復流程，確保核心功能的穩定性，並為 AI 協同開發提供清晰的指引。

## 基本原則
* **增量構建**：一次專注於一組相關功能。
* **優先測試**：依照定義的優先順序列測試功能。
* **明確的驗收標準**：每個階段都有在進入下一階段前必須達成的明確目標。
* **隔離變數**：為集中解決問題，非目前階段焦點的功能可能會被暫時停用。

---

## 階段 1：核心視窗建立與基礎互動

### 步驟 1.1：主視窗 (`NineBoxPreviewView`) 基礎功能
* **階段目標**：確保主預覽視窗能正確初始化、顯示，並響應基本的 GlyphsApp 選擇。
* **聚焦功能/模組**：
    * `NineBoxWindow` 的主視窗部分初始化。
    * `NineBoxPreviewView` 的 `initWithFrame_plugin_` 及基礎 `drawRect_` 邏輯，能正確繪製背景和中央預留位置。
    * 從 `plugin.py` 取得最基本的資料以供顯示（例如，僅顯示 Glyphs 目前選擇的字符於中央）。
* **驗收標準**：
    * 外掛載入無誤。
    * 主視窗能透過選單開啟。
    * 主視窗中央能正確顯示目前在 Glyphs 中編輯的字符（即便周圍8格暫不處理）。
    * 主視窗背景（明/暗模式）能正確根據 Glyphs 設定顯示。
    * 無主視窗初始化或基礎繪製相關的控制台錯誤。
* **暫時停用的功能**：控制面板所有功能、周圍8個字符的顯示邏輯、字符鎖定、搜尋、隨機排列、縮放等。
* **關鍵程式碼檔案**：`plugin.py` (基礎狀態), `window_controller.py` (主視窗部分), `preview_view.py` (基礎繪製)。

### 步驟 1.2：子視窗 (控制面板 `ControlsPanelView`) 基礎功能
* **階段目標**：確保控制面板視窗能正確初始化、顯示/隱藏，並與主視窗正確連動其位置和基本可見性。
* **聚焦功能/模組**：
    * `NineBoxWindow` 中與 `controlsPanelWindow` 和 `controlsPanelView` 相關的建立、設定 (`createControlsPanelWindow`, `_configure_controls_panel_window`)。
    * `ControlsPanelView` 的 `initWithFrame_plugin_` 及基礎 `setupUI`，僅確保畫面和按鈕等UI元件被建立，不要求功能完整。
    * 控制面板顯示/隱藏按鈕 (`controlsPanelButton` 及 `controlsPanelAction_`) 的基礎功能。
    * 載入 `CONTROLS_PANEL_VISIBLE_KEY` 偏好設定。
* **驗收標準**：
    * 控制面板能根據偏好設定在啟動時決定是否顯示。
    * 控制面板的顯示/隱藏按鈕能正常切換其可見性。
    * 控制面板的 UI 元件（如搜尋框、按鈕）已建立並可見（即使功能未實作）。
    * 無控制面板初始化相關的控制台錯誤。
* **暫時停用的功能**：控制面板內所有元件的實際邏輯功能（搜尋、鎖定、隨機等）。
* **關鍵程式碼檔案**：`window_controller.py` (控制面板管理), `controls_panel_view.py` (UI建立), `plugin.py` (偏好設定載入)。

### 步驟 1.3：視窗交互狀態
* **階段目標**：確保主視窗的大小調整、移動能正確影響主預覽畫面和控制面板的位置/大小。
* **聚焦功能/模組**：
    * `NineBoxWindow` 中的 `windowDidResize_` 和 `windowDidMove_`。
    * `NineBoxPreviewView` 的 `setFrame_` 和 `force_redraw`。
    * `ControlsPanelView` 的 `setFrame_` 及 `updateControlsPanelPosition`。
* **驗收標準**：
    * 調整主視窗大小時，`NineBoxPreviewView` 能正確填滿主視窗內容區域並觸發重繪。
    * 調整主視窗大小或移動主視窗時，`ControlsPanelView` 能保持在主視窗右側，且高度與主視窗同步。
    * 無上述操作相關的佈局錯誤或控制台錯誤。
* **暫時停用的功能**：控制面板內元件的詳細功能。
* **關鍵程式碼檔案**：`window_controller.py`, `preview_view.py`。

---

## 階段 2：核心輸入與繪製交互

### 步驟 2.1：長文字輸入框 (搜尋欄位 `searchField`) 與主預覽交互 (部分調整)
* **階段目標**：實作搜尋欄位支援長文字/多行輸入，並能將解析出的字符更新到 `plugin.selectedChars` 及 `plugin.currentArrangement`，並觸發主預覽視窗重繪周圍8個字符。
* **聚焦功能/模組**：(同上一版計畫)
* **驗收標準**：(同上一版計畫)
* **暫時停用的功能**：(同上一版計畫)
* **關鍵程式碼檔案**：(同上一版計畫)
* **【使用者澄清與確認 – 2025-06-03】(保留先前確認)**
    * **關於 `plugin.py` 中的 `parse_input_text` 函式：**
        * **問：** 當使用者在搜尋欄位輸入無效的字符名稱 (例如，字型中不存在的 Nice Name) 或格式錯誤的內容 (例如，連續多個空格、或是混雜了非預期符號) 時，`parse_input_text` 應該如何處理？
        * **答：** 忽略無效部分。
        * **問：** 在處理字符的 Nice Names 時，`parse_input_text` 和後續的 `generateNewArrangement` 是否需要考慮大小寫的差異？
        * **答：** 需要考慮大小寫差異。
    * **關於 `NineBoxPreviewView` 的 `drawRect_` 繪製邏輯：**
        * **問：** 如果使用者在搜尋欄輸入的字符數量不足以填滿周圍的 8 個格子 (例如，只輸入了 3 個字符)，那麼 `plugin.currentArrangement` 可能只包含 3 個有效字符。在這種情況下，`drawRect_` 應該如何處理剩餘的空格子？
        * **答：** 不足填滿時，使用已有字符重複輸入。需要另外注意，每個字符至少要出現一次。
        * **問：** 如果在 `plugin.currentArrangement` 中，有某個指定的字符實際上在目前的字型檔案中並不存在 (例如，使用者輸入了一個存在於其他字型但目前字型沒有的 Nice Name)，`drawRect_` 在繪製該格子時應該如何反應？
        * **答：** 跳過不繪製。只填充已存在的字符。
    * **關於偏好設定的儲存與載入 (`LAST_INPUT_KEY`, `SELECTED_CHARS_KEY`)：**
        * **問：** 這些偏好設定（上次的輸入內容和解析出的選定字符）應該在何時儲存？
        * **答：** 關閉視窗時儲存。
        * **問：** 如果在啟動外掛並載入偏好設定時，發現 `SELECTED_CHARS_KEY` 中儲存的某些字符在目前開啟的字型中已經不存在了，系統應該如何處理這種情況？
        * **答：** 依然顯示在輸入框中，但是繪製畫面跳過這些字符。

### 步驟 2.2：鎖定輸入框 (`lockFields`) - 資料處理 (已完成，根據使用者反饋調整闡述)
* **階段目標**：實作八個鎖定輸入框的基本資料處理，允許使用者輸入字符/Nice Names 並將其儲存到 `plugin.lockedChars`。輸入框不應阻止使用者輸入任何內容，交由後續邏輯判斷有效性。對於模糊輸入，應能處理中間態的預覽。
* **聚焦功能/模組**：
    * `ControlsPanelView`: `LockCharacterField` 實例及其 `textDidChange_` 回呼。
    * `plugin.py`: `smartLockCharacterCallback` 邏輯，用於識別輸入並更新 `self.lockedChars`。
    * `plugin.py`: `_recognize_character` 工具函式。
    * `plugin.py`: 從偏好設定中儲存和載入 `LOCKED_CHARS_KEY`。
* **驗收標準**：
    * 使用者可以在八個 `LockCharacterField` 中自由輸入任何文字。
    * `LockCharacterField` 的 `textDidChange_` 回呼應能處理**模糊輸入**：例如，當使用者輸入 "A.alt"，在輸入到 "A" 時，若字型中存在 "A"，預覽應嘗試顯示 "A"；當使用者完成輸入 "A.alt" 後，若 "A.alt" 有效，則預覽更新為 "A.alt"。
    * 每個 `LockCharacterField` 中的有效輸入能正確更新 `self.plugin.lockedChars` 中對應的條目。
    * `smartLockCharacterCallback` 能正確識別有效字符/Nice Name，對於無效輸入則不更新或清除對應的 `lockedChars` 條目。
    * `self.plugin.lockedChars` 在呼叫 `savePreferences` 時能被正確儲存。
    * 當外掛啟動或呼叫 `loadPreferences` 時，`self.plugin.lockedChars` 能從偏好設定中正確載入並填充到 `LockCharacterField`。
    * 如果鎖定欄位被清空（輸入為空），則從 `self.plugin.lockedChars` 中移除對應的條目。
* **暫時停用的功能**：`lockedChars` 與 `NineBoxPreviewView` 繪製的交互（將在下一階段處理）、`lockButton` 功能、清除/還原全部按鈕。
* **關鍵程式碼檔案**：`controls_panel_view.py`, `plugin.py`。
* **【先前使用者待補充已澄清】**：
    * 對於模糊輸入 "A.alt" vs "A"：優先顯示已輸入部分的最長有效配對，輸入完成後更新為最終配對。
    * `smartLockCharacterCallback` 不應阻止輸入，其檢查 `_get_lock_state()` 的邏輯將在階段 3.1 中調整。

---

## 階段 3：鎖定控制與核心交互

### 步驟 3.1：全域鎖頭按鈕 (置中) 與鎖定交互
* **階段目標**：實作位於九宮格鎖定輸入區中央的全域「鎖頭按鈕 (🔓/🔒)」功能，並使其能正確控制 `lockedChars` 是否套用於預覽。**按鈕預設狀態為「🔒 上鎖」。鎖頭圖示使用 Unicode 字符並填色。鎖頭狀態切換時，預覽應立即重繪。**
* **聚焦功能/模組**：
    * `ControlsPanelView`:
        * 建立並佈局全域鎖頭按鈕 (`lockButton`) 於九宮格鎖定輸入區的中央位置。
        * `lockButton` (`NSButtonTypeToggle`) 的視覺呈現：**使用 Unicode 字符 (例如 U+1F512 🔒, U+1F513 🔓) 並設定適當的顏色 (例如，鎖定為一種顏色，解鎖為另一種，或根據主題調整)**。需與周圍輸入框有視覺區分。
        * `toggleLockMode_` 動作, `updateLockButton` UI 更新 (更新按鈕的 Unicode 字符及顏色)。
        * `isInClearMode` 屬性：**初始值設為 `False` (對應「🔒 上鎖」狀態)**。
        * 八個 `LockCharacterField` 始終保持可編輯狀態。
    * `plugin.py`:
        * `_get_lock_state()` 方法，從 `controlsPanelView` 讀取 `isInClearMode`。
        * `smartLockCharacterCallback`：移除對 `_get_lock_state()` 的檢查。鎖定框的輸入總是會嘗試更新 `self.plugin.lockedChars`。
        * `generateNewArrangement` 在決定是否呼叫 `apply_locked_chars` 時，依然遵守 `_get_lock_state()`。
        * **新增**：在 `toggleLockMode_` (或其觸發的 `plugin` 層回呼) 中，確保呼叫 `self.plugin.updateInterface(None)` 或直接請求主視窗重繪，以實作鎖頭狀態切換時預覽的**立即重繪**。
* **驗收標準**：
    * 全域鎖頭按鈕正確顯示在九宮格鎖定輸入區的中央，使用指定的 Unicode 字符和顏色，並與周圍輸入框有視覺區分。
    * 外掛啟動並首次顯示控制面板時，鎖頭按鈕預設顯示為「🔒」(上鎖狀態對應的 Unicode 字符和顏色)，且 `controlsPanelView.isInClearMode` 為 `False`。
    * 點擊鎖頭按鈕能切換其圖示和顏色在「🔓」和「🔒」之間，並更新 `controlsPanelView.isInClearMode` 狀態。
    * **當鎖頭狀態從「🔒 上鎖」切換到「🔓 解鎖」時，或反之，`NineBoxPreviewView` 立即重繪以反映鎖定套用狀態的變化。**
    * 八個 `LockCharacterField` 始終可編輯，其輸入會更新 `plugin.lockedChars`，無論鎖頭按鈕為何種狀態。
    * 當鎖頭按鈕為「🔓」( `isInClearMode == True` ) 時：
        * `generateNewArrangement` *不*套用 `lockedChars` 到預覽。
    * 當鎖頭按鈕為「🔒」( `isInClearMode == False` ) 時：
        * `generateNewArrangement` 會將 `lockedChars` 套用到預覽中。
    * 鎖頭按鈕的狀態不儲存到偏好設定中，每次啟動外掛時，控制面板的鎖頭狀態固定預設為「🔒 上鎖」。
    * 鎖定輸入框的變更 (更新 `plugin.lockedChars`) 或鎖頭狀態的變更，應能觸發 `NineBoxPreviewView` 重繪。
* **關鍵程式碼檔案**：`controls_panel_view.py`, `plugin.py`。

### 步驟 3.2：「清空欄位」圖示按鈕
* **階段目標**：實作圖示化的「清空欄位」按鈕（**優先考慮 🧹 圖示，若實作困難或顯示效果不佳，則使用文字「清空欄位」**），用於清除所有八個鎖定輸入框的文字內容，並間接觸發清除 `plugin.lockedChars` 中對應的鎖定記憶。
* **聚焦功能/模組**：
    * `ControlsPanelView`:
        * 建立一個新的按鈕。**優先嘗試使用 🧹 (U+1F9F9 BROOM) 圖示。如果設定圖示按鈕在 Cocoa 中過於複雜或效果不理想，則退回使用文字標籤「清空欄位」。**
        * 該按鈕觸發一個新的動作，例如 `clearAllLockInputFieldsAction_`。
    * `plugin.py`:
        * 實作一個新的回呼函式，例如 `clearAllLockInputFieldsCallback`。
        * 此回呼函式需要：
            1.  遍歷 `ControlsPanelView` 中的所有八個 `LockCharacterField`，將它們的 `setStringValue_("")` 設為空字串。
            2.  由於 `LockCharacterField` 的內容變為空，`smartLockCharacterCallback` 會被每個欄位觸發，進而從 `self.plugin.lockedChars` 中移除對應的條目。
            3.  觸發預覽更新 (`self.updateInterface(None)` 或類似機制)。
            4.  儲存偏好設定 (因為 `LOCKED_CHARS_KEY` 已改變)。
* **驗收標準**：
    * 控制面板上出現一個「清空欄位」按鈕（優先為 🧹 圖示，備選為文字）。
    * 點擊該按鈕後：
        * 所有八個 `LockCharacterField` 的文字內容被清空。
        * `self.plugin.lockedChars` 變為空字典。
        * `NineBoxPreviewView` 重繪。
        * 相關偏好設定 (`LOCKED_CHARS_KEY`) 被更新。
* **關鍵程式碼檔案**：`controls_panel_view.py`, `plugin.py`。

---

## 階段 4：輔助功能與最終潤飾

### 步驟 4.1：字符選擇器 (`pickGlyphCallback`) - 行為調整與潛在移除評估
* **階段目標**：實作字符選擇器功能，使其能正確區分是從搜尋框還是從單個鎖定框觸發，並進行相應處理。**同時，評估在處理大量字符集字型時，若 `Glyphs.displayDialog` 效能/可用性不佳，則考慮移除此右鍵選單功能，或尋找替代方案。**
* **聚焦功能/模組**：
    * `plugin.py`: `pickGlyphCallback`, `_prepare_glyph_options`, `_parse_glyph_selection`。
    * `ControlsPanelView`: `searchField` ( `CustomTextField` ) 和 `LockCharacterField` 上的右鍵選單項「從字型中選擇字符...」。
    * `BaseTextField`: `pickGlyphAction_` 方法。
    * **新增/修改**：
        * `pickGlyphAction_` 需要能將觸發事件的控件實例 ( `sender` ) 傳遞給 `pickGlyphCallback`。
        * `pickGlyphCallback` 內部邏輯需要判斷 `sender` 的類型（是 `CustomTextField` 還是 `LockCharacterField`）以及（如果是 `LockCharacterField`）其在九宮格中的位置。
* **驗收標準**：
    * 在 `searchField` 以及每個 `LockCharacterField` 上右鍵點擊會顯示「從字型中選擇字符...」的選單項。
    * **初步測試**：使用包含少量字符的字型進行測試。
        * 點擊選單項後，`Glyphs.displayDialog` 能開啟並列出字符。
        * 列表格式為 `字符 (glyph.name)` 或 `.notdef (glyph.name)`。
        * 允許使用 Shift/Cmd 進行多項選擇。
        * **如果從 `searchField` 觸發**：選定的字符（或多個字符拼接）更新 `self.plugin.selectedChars` 和 `self.plugin.lastInput`，觸發 `generateNewArrangement` 和預覽重繪。
        * **如果從某個 `LockCharacterField` 觸發**：
            * 只取選中的第一個有效字符。
            * 將該字符更新到**觸發事件的那個特定** `LockCharacterField` 的內容中。
            * 觸發 `smartLockCharacterCallback` 以更新 `self.plugin.lockedChars` 中對應位置的條目。
            * `NineBoxPreviewView` 重繪。
        * 偏好設定被儲存。
    * **大量字符集評估**：
        * **測試**：使用一個包含大量字符（例如數千個 CJK 字符）的字型來測試此功能。
        * **評估標準**：
            * `Glyphs.displayDialog` 的開啟速度是否在可接受範圍內（例如，不超過幾秒鐘）。
            * 列表顯示後，滾動和選擇操作是否流暢。
            * 整體使用者體驗是否便捷。
        * **決策點**：
            * **如果效能和可用性可接受**：保留此功能。
            * **如果效能或可用性嚴重不佳**：**考慮在本版本中移除此右鍵選單功能**，並在 README 或說明文檔中註明，未來可能尋找更優方案。或者，如果 Glyphs 提供了其他更合適的內建字符選擇UI接口，則研究替換。
* **關鍵程式碼檔案**：`plugin.py`, `controls_panel_view.py`。
* **【先前使用者待補充已澄清/調整】**：
    * **大量字符集問題已納入評估與決策點。**
    * **字符選擇器對單個 `LockCharacterField` 的行為已明確。**

### 步驟 4.2：介面佈局與風格極簡化
* **階段目標**：實作最終的極簡UI佈局。**如果步驟 4.1 中決定移除字符選擇器功能，則相關的右鍵選單邏輯也將被移除或註釋掉。**
* **聚焦功能/模組**：
    * `ControlsPanelView`:
        * **搜尋框**：實作為支援長文字/多行輸入。
        * **移除「鎖定位置：」文字標籤 (`titleLabel`)**。
        * **九宮格鎖定輸入區**：
            * 八個 `LockCharacterField` (加大字型)。
            * 中央放置全域**鎖頭按鈕 (🔓/🔒)**，使用 **Unicode 字符並設定顏色**。
        * **「清空欄位」按鈕**：實作為**優先 🧹 圖示，備選文字「清空欄位」**。
        * 所有 UI 元素的精確佈局、間距、對齊。
        * **(潛在移除)** `BaseTextField` 中的右鍵選單設定程式碼。
    * `NineBoxWindow`: 主視窗標題列按鈕 ("⚙") 保持不變。
    * 所有互動元素的 Tooltip 和在地化字串 (`Glyphs.localize`)。
* **驗收標準**：
    * 控制面板 UI 符合最終確認的極簡佈局方案。
    * 所有元素對齊、間距均勻、尺寸合適。
    * 所有可互動元素都有相應的 Tooltip 提示。
    * 所有文字元素都使用 `Glyphs.localize` 進行在地化。
    * 無佈局相關的視覺缺陷或控制台錯誤。
    * **(新增/修改)** 如果字符選擇器功能被移除，則 `searchField` 和 `LockCharacterField` 上不應再出現「從字型中選擇字符...」的右鍵選單。
* **關鍵程式碼檔案**：`controls_panel_view.py` (主要), `window_controller.py`, `plugin.py`。
* **【使用者待補充】(部分已澄清)**：
    * 「清空欄位」按鈕的確切圖示選擇 🧹 或使用文字。
    * 需要完整支援和測試在地化的所有語言列表。

---

## 階段 5：程式碼最佳化與維護性改進

### 步驟 5.1：程式碼清理與重構
* **階段目標**：確保目前功能完整的情況下，清理冗餘程式碼，提高整體程式碼品質和可維護性。
* **聚焦功能/模組**：
    * `constants.py`: 移除已註解的開發程式碼，最佳化常數組織。
    * `utils.py`: 最佳化除錯記錄函數，統一格式並確保只在除錯模式下輸出。
    * `plugin.py`: 重構模組匯入，最佳化事件處理函數，簡化邏輯結構。
    * 所有模組: 檢查和改進方法文檔，為關鍵函數新增完整的參數和回傳值說明。
* **驗收標準**：
    * 移除所有未使用的註解程式碼和開發時的調試工具。
    * 所有除錯輸出統一使用 `debug_log` 函數，並受 `DEBUG_MODE` 常數控制。
    * 模組匯入按功能分類整理，減少重複匯入。
    * 關鍵方法的邏輯結構更加清晰，移除不必要的條件分支。
    * 主要函數擁有完整的文檔字符串，包含參數和回傳值說明。
    * 所有最佳化不影響現有功能的正常運作。
* **關鍵程式碼檔案**：`constants.py`, `utils.py`, `plugin.py`, `window_controller.py`, `preview_view.py`, `controls_panel_view.py`。

### 步驟 5.2：效能最佳化
* **階段目標**：最佳化資源使用和效能，特別是在處理大型字型和快速操作時。
* **聚焦功能/模組**：
    * `utils.py`: 改進快取機制，減少重複計算和查詢。
    * `plugin.py`: 實作批次更新機制，避免短時間內重複重繪。
    * `preview_view.py`: 最佳化繪製邏輯，確保繪製效率。
    * 所有模組: 檢查和最佳化資源管理，確保適當釋放和重建資源。
* **驗收標準**：
    * 使用 `_update_scheduled` 標記防止短時間內的重複更新請求。
    * 實作選擇性更新機制，例如搜尋欄位變更時不更新鎖定輸入框。
    * 最佳化字符排列生成邏輯，減少不必要的操作。
    * 完善視窗生命週期管理，確保資源正確釋放。
    * 在大型字型（超過5000個字符）下操作流暢，無明顯卡頓。
* **關鍵程式碼檔案**：`utils.py`, `plugin.py`, `preview_view.py`。

### 步驟 5.3：錯誤處理與穩定性提升
* **階段目標**：增強外掛的穩定性和錯誤恢復能力，確保在各種異常情況下能夠優雅處理。
* **聚焦功能/模組**：
    * 所有模組: 完善異常捕獲和處理，避免程式崩潰。
    * `plugin.py`: 在關鍵功能處增加參數檢查和預設值處理。
    * `window_controller.py`: 最佳化視窗資源管理，確保在關閉/重開時正確處理。
    * `utils.py`: 改進字符解析和驗證邏輯，處理邊界情況。
* **驗收標準**：
    * 所有關鍵函數都有適當的異常處理，並記錄具體錯誤訊息。
    * 外掛能夠在關閉後重新開啟時保持狀態一致性。
    * 在無效輸入、字型切換或其他異常情況下能夠優雅降級，而不會崩潰。
    * 在啟動時能檢測並恢復可能損壞的偏好設定。
    * 通過測試邊界情況（例如極大/極小視窗尺寸、無效字符輸入、極速操作等）保持穩定執行。
* **關鍵程式碼檔案**：`plugin.py`, `window_controller.py`, `utils.py`。

### 步驟 5.4：技術文檔更新
* **階段目標**：更新技術規格檔案，反映程式碼最佳化和架構改進。
* **聚焦功能/模組**：
    * 更新 TSD 檔案，新增程式碼最佳化相關內容。
    * 更新架構圖和數據流描述，反映最佳化後的設計。
    * 新增效能考量和維護指南，便於未來開發者理解。
* **驗收標準**：
    * TSD 檔案版本更新為 1.11，日期更新為目前日期。
    * 新增「程式碼效能與維護性改進」新章節，詳述最佳化措施。
    * 更新主要模組職責描述，反映程式碼最佳化後的職責劃分。
    * 更新數據流描述，強調效能最佳化點。
    * 文檔內容與實際程式碼實作保持一致。
* **關鍵檔案**：`.cursor/rules/tsd.mdc`。
