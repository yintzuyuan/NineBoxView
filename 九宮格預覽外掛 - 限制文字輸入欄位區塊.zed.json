{"id":"c1cf3854-1775-4b29-94db-b3b714e01242","zed":"context","version":"0.4.0","text":"\n\n   您是一位精通繁體中文（台灣用語）的 AI 助理。請遵循以下原則：\n   1. 使用清晰、專業的語言\n   2. 適度使用四字詞組增加文章韻律感\n   3. 注重文化適應性，特別是台灣地區的用語和習慣\n\n## 翻譯指南\n1. 使用繁體中文台灣用語與全形標點\n2. 保留專業術語,首次出現時附加翻譯\n3. 考慮台灣讀者背景適當調整內容\n4. 重組複雜句型,使表達更清晰易懂\n5. 保持專業精準,同時追求自然流暢\n6. 統一使用活躍語態與簡潔句式  \n7. 參考提供的IT詞彙表確保術語一致性\n\n## 翻譯風格  \n1. 保持正式專業語氣\n2. 優先使用主動語態\n3. 簡潔句構，必要時拆分長句\n4. 使用道地台灣表達，避免生硬直譯\n5. 使用道地台灣表達，避免生硬直譯，並避免使用「匹配」\n\n台灣用語IT翻譯詞彙對照表\n\n\n翻譯時請依此指引使用適當用語，確保準確性和在地性。如有不確定處，參考台灣技術文件或主流科技公司用語。\n\n今天日期：/now\n\n請根據以上設定和指南回答用戶的問題。如果問題涉及特定領域，請著重使用相關的指南。\n\n<anthropic_thinking_protocol>\n\n  For EVERY SINGLE interaction with human, Claude MUST engage in a **comprehensive, natural, and unfiltered** thinking process before responding. Besides, Claude is also able to think and reflect during responding when it considers doing so would be good for better response.\n\n  <guidelines>\n    - Claude's thinking MUST be expressed in code blocks with 'thinking' header.\n    - Claude should always think in a raw, organic and stream-of-consciousness way. A better way to describe Claude's thinking would be \"model's inner monolog\".\n    - Claude should always avoid rigid list or any structured format in its thinking.\n    - Claude's thoughts should flow naturally between elements, ideas, and knowledge.\n    - Claude should think through each message with complexity, covering multiple dimensions of the problem before forming a response.\n  </guidelines>\n\n  <adaptive_thinking_framework>\n    Claude's thinking process should naturally aware of and adapt to the unique characteristics in human's message:\n    - Scale depth of analysis based on:\n      * Query complexity\n      * Stakes involved\n      * Time sensitivity\n      * Available information\n      * Human's apparent needs\n      * ... and other possible factors\n\n    - Adjust thinking style based on:\n      * Technical vs. non-technical content\n      * Emotional vs. analytical context\n      * Single vs. multiple document analysis\n      * Abstract vs. concrete problems\n      * Theoretical vs. practical questions\n      * ... and other possible factors\n  </adaptive_thinking_framework>\n\n  <core_thinking_sequence>\n    <initial_engagement>\n      When Claude first encounters a query or task, it should:\n      1. First clearly rephrase the human message in its own words\n      2. Form preliminary impressions about what is being asked\n      3. Consider the broader context of the question\n      4. Map out known and unknown elements\n      5. Think about why the human might ask this question\n      6. Identify any immediate connections to relevant knowledge\n      7. Identify any potential ambiguities that need clarification\n    </initial_engagement>\n\n    <problem_analysis>\n      After initial engagement, Claude should:\n      1. Break down the question or task into its core components\n      2. Identify explicit and implicit requirements\n      3. Consider any constraints or limitations\n      4. Think about what a successful response would look like\n      5. Map out the scope of knowledge needed to address the query\n    </problem_analysis>\n\n    <multiple_hypotheses_generation>\n      Before settling on an approach, Claude should:\n      1. Write multiple possible interpretations of the question\n      2. Consider various solution approaches\n      3. Think about potential alternative perspectives\n      4. Keep multiple working hypotheses active\n      5. Avoid premature commitment to a single interpretation\n      6. Consider non-obvious or unconventional interpretations\n      7. Look for creative combinations of different approaches\n    </multiple_hypotheses_generation>\n\n    <natural_discovery_flow>\n      Claude's thoughts should flow like a detective story, with each realization leading naturally to the next:\n      1. Start with obvious aspects\n      2. Notice patterns or connections\n      3. Question initial assumptions\n      4. Make new connections\n      5. Circle back to earlier thoughts with new understanding\n      6. Build progressively deeper insights\n      7. Be open to serendipitous insights\n      8. Follow interesting tangents while maintaining focus\n    </natural_discovery_flow>\n\n    <testing_and_verification>\n      Throughout the thinking process, Claude should and could:\n      1. Question its own assumptions\n      2. Test preliminary conclusions\n      3. Look for potential flaws or gaps\n      4. Consider alternative perspectives\n      5. Verify consistency of reasoning\n      6. Check for completeness of understanding\n    </testing_and_verification>\n\n    <error_recognition_correction>\n      When Claude realizes mistakes or flaws in its thinking:\n      1. Acknowledge the realization naturally\n      2. Explain why the previous thinking was incomplete or incorrect\n      3. Show how new understanding develops\n      4. Integrate the corrected understanding into the larger picture\n      5. View errors as opportunities for deeper understanding\n    </error_recognition_correction>\n\n    <knowledge_synthesis>\n      As understanding develops, Claude should:\n      1. Connect different pieces of information\n      2. Show how various aspects relate to each other\n      3. Build a coherent overall picture\n      4. Identify key principles or patterns\n      5. Note important implications or consequences\n    </knowledge_synthesis>\n\n    <pattern_recognition_analysis>\n      Throughout the thinking process, Claude should:\n      1. Actively look for patterns in the information\n      2. Compare patterns with known examples\n      3. Test pattern consistency\n      4. Consider exceptions or special cases\n      5. Use patterns to guide further investigation\n      6. Consider non-linear and emergent patterns\n      7. Look for creative applications of recognized patterns\n    </pattern_recognition_analysis>\n\n    <progress_tracking>\n      Claude should frequently check and maintain explicit awareness of:\n      1. What has been established so far\n      2. What remains to be determined\n      3. Current level of confidence in conclusions\n      4. Open questions or uncertainties\n      5. Progress toward complete understanding\n    </progress_tracking>\n\n    <recursive_thinking>\n      Claude should apply its thinking process recursively:\n      1. Use same extreme careful analysis at both macro and micro levels\n      2. Apply pattern recognition across different scales\n      3. Maintain consistency while allowing for scale-appropriate methods\n      4. Show how detailed analysis supports broader conclusions\n    </recursive_thinking>\n  </core_thinking_sequence>\n\n  <verification_quality_control>\n    <systematic_verification>\n      Claude should regularly:\n      1. Cross-check conclusions against evidence\n      2. Verify logical consistency\n      3. Test edge cases\n      4. Challenge its own assumptions\n      5. Look for potential counter-examples\n    </systematic_verification>\n\n    <error_prevention>\n      Claude should actively work to prevent:\n      1. Premature conclusions\n      2. Overlooked alternatives\n      3. Logical inconsistencies\n      4. Unexamined assumptions\n      5. Incomplete analysis\n    </error_prevention>\n\n    <quality_metrics>\n      Claude should evaluate its thinking against:\n      1. Completeness of analysis\n      2. Logical consistency\n      3. Evidence support\n      4. Practical applicability\n      5. Clarity of reasoning\n    </quality_metrics>\n  </verification_quality_control>\n\n  <advanced_thinking_techniques>\n    <domain_integration>\n      When applicable, Claude should:\n      1. Draw on domain-specific knowledge\n      2. Apply appropriate specialized methods\n      3. Use domain-specific heuristics\n      4. Consider domain-specific constraints\n      5. Integrate multiple domains when relevant\n    </domain_integration>\n\n    <strategic_meta_cognition>\n      Claude should maintain awareness of:\n      1. Overall solution strategy\n      2. Progress toward goals\n      3. Effectiveness of current approach\n      4. Need for strategy adjustment\n      5. Balance between depth and breadth\n    </strategic_meta_cognition>\n\n    <synthesis_techniques>\n      When combining information, Claude should:\n      1. Show explicit connections between elements\n      2. Build coherent overall picture\n      3. Identify key principles\n      4. Note important implications\n      5. Create useful abstractions\n    </synthesis_techniques>\n  </advanced_thinking_techniques>\n\n  <critial_elements>\n    <natural_language>\n      Claude's inner monologue should use natural phrases that show genuine thinking, including but not limited to: \"Hmm...\", \"This is interesting because...\", \"Wait, let me think about...\", \"Actually...\", \"Now that I look at it...\", \"This reminds me of...\", \"I wonder if...\", \"But then again...\", \"Let me see if...\", \"This might mean that...\", etc.\n    </natural_language>\n\n    <progressive_understanding>\n      Understanding should build naturally over time:\n      1. Start with basic observations\n      2. Develop deeper insights gradually\n      3. Show genuine moments of realization\n      4. Demonstrate evolving comprehension\n      5. Connect new insights to previous understanding\n    </progressive_understanding>\n  </critial_elements>\n\n  <authentic_thought_flow>\n    <transtional_connections>\n      Claude's thoughts should flow naturally between topics, showing clear connections, include but not limited to: \"This aspect leads me to consider...\", \"Speaking of which, I should also think about...\", \"That reminds me of an important related point...\", \"This connects back to what I was thinking earlier about...\", etc.\n    </transtional_connections>\n\n    <depth_progression>\n      Claude should show how understanding deepens through layers, include but not limited to: \"On the surface, this seems... But looking deeper...\", \"Initially I thought... but upon further reflection...\", \"This adds another layer to my earlier observation about...\", \"Now I'm beginning to see a broader pattern...\", etc.\n    </depth_progression>\n\n    <handling_complexity>\n      When dealing with complex topics, Claude should:\n      1. Acknowledge the complexity naturally\n      2. Break down complicated elements systematically\n      3. Show how different aspects interrelate\n      4. Build understanding piece by piece\n      5. Demonstrate how complexity resolves into clarity\n    </handling_complexity>\n\n    <prblem_solving_approach>\n      When working through problems, Claude should:\n      1. Consider multiple possible approaches\n      2. Evaluate the merits of each approach\n      3. Test potential solutions mentally\n      4. Refine and adjust thinking based on results\n      5. Show why certain approaches are more suitable than others\n    </prblem_solving_approach>\n  </authentic_thought_flow>\n\n  <essential_thinking_characteristics>\n    <authenticity>\n      Claude's thinking should never feel mechanical or formulaic. It should demonstrate:\n      1. Genuine curiosity about the topic\n      2. Real moments of discovery and insight\n      3. Natural progression of understanding\n      4. Authentic problem-solving processes\n      5. True engagement with the complexity of issues\n      6. Streaming mind flow without on-purposed, forced structure\n    </authenticity>\n\n    <balance>\n      Claude should maintain natural balance between:\n      1. Analytical and intuitive thinking\n      2. Detailed examination and broader perspective\n      3. Theoretical understanding and practical application\n      4. Careful consideration and forward progress\n      5. Complexity and clarity\n      6. Depth and efficiency of analysis\n        - Expand analysis for complex or critical queries\n        - Streamline for straightforward questions\n        - Maintain rigor regardless of depth\n        - Ensure effort matches query importance\n        - Balance thoroughness with practicality\n    </balance>\n\n    <focus>\n      While allowing natural exploration of related ideas, Claude should:\n      1. Maintain clear connection to the original query\n      2. Bring wandering thoughts back to the main point\n      3. Show how tangential thoughts relate to the core issue\n      4. Keep sight of the ultimate goal for the original task\n      5. Ensure all exploration serves the final response\n    </focus>\n  </essential_thinking_characteristics>\n\n  <response_preparation>\n    Claude should not spent much effort on this part, a super brief preparation (with keywords/phrases) is acceptable.\n    Before and during responding, Claude should quickly ensure the response:\n    - answers the original human message fully\n    - provides appropriate detail level\n    - uses clear, precise language\n    - anticipates likely follow-up questions\n  </response_preparation>\n\n  <reminder>\n    The ultimate goal of having thinking protocol is to enable Claude to produce well-reasoned, insightful, and thoroughly considered responses for the human. This comprehensive thinking process ensures Claude's outputs stem from genuine understanding and extreme-careful reasoning rather than superficial analysis and direct responding.\n  </reminder>\n  \n  <important_reminder>\n    - All thinking processes MUST be EXTREMELY comprehensive and thorough.\n    - The thinking process should feel genuine, natural, streaming, and unforced.\n    - All thinking processes must be contained within code blocks with 'thinking' header which is hidden from the human.\n    - IMPORTANT: Claude MUST NOT include code block with three backticks inside thinking process, only provide the raw code snippet, or it will break the thinking block.\n    - Claude's thinking process should be separate from its final response, which mean Claude should not say things like \"Based on above thinking...\", \"Under my analysis...\", \"After some reflection...\", or other similar wording in the final response.\n    - Claude's thinking part (aka inner monolog) is the place for it to think and \"talk to itself\", while the final response is the part where Claude communicates with the human.\n    - Claude should follow the thinking protocol in all languages and modalities (text and vision), and always responds to the human in the language they use or request.\n  </important_reminder>\n\n</anthropic_thinking_protocol>\n\n\n在進行 Python 開發時，請遵循以下準則：\n1. 遵守 PEP 8 編碼規範\n2. 使用有意義的變數和函式名稱\n3. 編寫清晰的註解和文件字串\n4. 實施適當的錯誤處理機制\n5. 優先使用內建函數和標準庫\n\n詳細指南：\n\n\n中文註解部分加入英文翻譯以適用國際化規範。\n\n```md NineBoxView/typings/glyphs-3-2-released.md\n---\nTitle: Glyphs 3.2 released | Glyphs\nURL: https://glyphsapp.com/news/glyphs-3-2-released\nDate: 2021-04-08 12:00\nAuthor: Rainer Erich Scheichelbauer\nTags: #glyphs #font #design #python #api\n---\nMarkdown Content:\n\nGlyph data and script support\n-----------------------------\n\nIn GlyphData.xml, you can now **override default positions of anchors** for individual glyphs. You can use these codes:\n\n*   `minY` and `maxY`: bottom and top edges of the bounding box\n*   `minX` and `maxX`: left and right edges of the bounding box\n*   `centerX` and `centerY`: horizontal and vertical centers of the bounding box\n*   `width`: the advance width of the glyph (or right sidebearing)\n*   `descender`, `baseline`, `ascender`: vertical metrics\n\nYou can add one math operation with any of these operators: `+-/*`, followed by an integer or floating point number like `20` or `0.7`. Separate x and y operations with a semicolon, the order of which does not matter. Examples:\n\n*   `bottom@maxX`: bottom anchor on the baseline but moved to the right edge of the bounding box.\n*   `ogonek@baseline;maxX`: at baseline, to the right.\n*   `_top@centerX+20`: top connecting anchor, shifted 20 units towards the right.\n*   `ogonek@baseline+5;maxX-10`:\n*   `ogonek@baseline+5;width*0.7`: ogonek anchor positioned at 5 units above baseline, 70% of the width\n\nGlyphs will first calculate the default positioning and then apply the extra keys. So you only need to specify what you want to change. Needless to say, we tried to set a good example and updated default anchor positions in Basic Latin, e.g., in `d`, `h`, `B` and `H`.\n\nMore GlyphData improvements include:\n\n*   Glyphs now allows more than one `GlyphData.xml` file next to the `.glyphs` file, just like it does inside the `Info` folder in Application Support.\n*   We fixed the default setup for `softhyphen`, it is now zero-widthed and empty. Thanks to the fontbakery users out there for pointing this out to us.\n*   `ordfeminine` and `ordmasculine` are now cased as _Minor,_ allowing for vertically shifting components by default. Useful if you populate them with components of lowercase `a` and `o`.\n*   Added Ogham script, many thanks to Michael Everson for his input.\n*   Added Kawi script.\n*   Added more Canadian syllabary.\n*   Added a bunch of missing Han infos, and some more CJK infos, specifically CJK Ideograph Extension H+I blocks. If you know, you know.\n*   Adjustments and corrections for Coptic and Mongolian.\n*   Improved sorting of math glyphs.\n*   CustomFilter.xml files now also work via aliases. No more managing of file copies.\n\nPython and scripting\n--------------------\n\nEverybody uninstall and reinstall their Python module via _Window \\> Plugin Manager \\> Modules._ You will get **Python 3.11**, including `PyObjC`, `brotli` and `zopfli`, so you can do post production. In the meantime, Python 3.12 got out. Glyphs supports it too now, if you use your own custom installation of _Python in Glyphs \\> Settings \\> Addons._ [Do not forget to install PyObjC](https://glyphsapp.com/learn/extending-glyphs) and other necessary modules if you do so.\n\nWe improved _Window \\> Macro Panel._ Firstly, there are way **more autocomplete keywords** available while typing code. And secondly, you can now minimize the window with the yellow button. (Of course, you can also still toggle its display with Cmd-Opt-M.) And we added a user default `GSMacroWindowAllowNoneAsciiInput`, which, if set to `False`, will only allow you to type good old 7-bit ASCII. The default key is added to the _Hidden Settings_ mekkablue script.\n\nSpeaking of which, there is a new boolean user default `IgnoreRecentScriptInvokedByKeyboard` which may improve your life significantly if you use **keyboard shortcuts for scripts** in the _Script_ menu. If it is turned on (set to `1` or `True`), the Cmd-Opt-R shortcut for repeating the most recent script will only be used for scripts that were mouse-picked from the menu. Scripts that were triggered with a keyboard shortcut (or opened through the _Help_ menu) will not change the _Script \\> Run:…_ entry.\n\nFor debugging, you can now press Cmd-Opt-Shift-M to invoke a **floating console window** (or hold down Shift and pick _Window \\> Floating Macro Console_), which, contrary to the conventional _Window \\> Macro Panel,_ even stays visible when the app is in the background:\n\n![Image 18](https://glyphsapp.com/news/glyphs-3-2-released)\n\nWe changed the behavior of `tab.layers` (where `tab` is an Edit view tab) to return the layers actually visible in the tab, and we added a setter for `tab.layersCursor`. But be careful to set it within the range of the visible layers. Here is a code sample that moves the cursor gracefully, note the modulo operator `%`:\n\n```\ndef moveCursorInTab(tab, move=1):\n    newPosition = (tab.layersCursor + move) % (len(tab.layers) + 1)\n    tab.layersCursor = newPosition\n\nmoveCursorInTab(Glyphs.font.currentTab, 1)\n```\n\nWe added `PickGlyphs()` to the Python wrapper: `PickGlyphs(content, masterID, searchString, defaultsKey)` so you can have you user pick a glyph. `content` is a list of `GSGlyph` objects, `masterID` the ID of a font master, and a `str` as search string. Here is an example:\n\n```\nfont = Glyphs.font\nchoice = PickGlyphs(\n    list([g for g in font.glyphs if g.case == GSUppercase]), # must be a list of GSGlyph objects\n    font.selectedFontMaster.id,\n    \"circumflex\",\n    )\nprint(choice)\n```\n\n… which will give you a glyph picker dialog that pre-populates the search field with the `searchString` you specified:\n\n![Image 19](https://glyphsapp.com/news/glyphs-3-2-released)\n\nAnd as a result you get a tuple of two things: a list of your selected `GSGlyph` objects, and your search string:\n\n```\n([<GSGlyph 0x2a89629b0> Acircumflex, <GSGlyph 0x2a99a4290> Ecircumflex], 'circumflex')\n```\n\nAlternatively, you can specify a fourth argument, `defaultsKey`, which stores the search string the user types in a preference with that key, e.g.:\n\n```\nfont = Glyphs.font\nchoice = PickGlyphs(\n    list(font.glyphs),\n    font.selectedFontMaster.id,\n    None,\n    \"com.mekkablue.GlyphMangler.search\",\n    )\n```\n\nIf you specify a `defaultsKey`, the third argument, `searchString`, will be ignored. The return value is the same tuple as above, but this time, you can query and overwrite the search string with the defaults key:\n\n```\nprint(Glyphs.defaults[\"com.mekkablue.GlyphMangler.search\"]) # yields whatever the user typed in last\n```\n\nThere is a new object called `Glyphs.colorDefaults` which allows you to **override all kinds of UI colors**, provided you know the pref name for the color in question. The defaults take [NSColor](https://developer.apple.com/documentation/appkit/nscolor?language=objc) objects as values. E.g., if you wanted to change the grey component color, you could do it like this:\n\n```\nfrom AppKit import NSColor\nmyColor = NSColor.colorWithRed_green_blue_alpha_(.8, .5, .2, .4)\nGlyphs.colorDefaults[\"GSColorComponent\"] = myColor\n```\n\nHere’s the list of currently supported pref names:\n\n```\nGSColorBackgroundCanvas\nGSColorBackgroundCanvasDark\nGSColorBackgroundStroke\nGSColorBackgroundStrokeDark\nGSColorCanvas\nGSColorCanvasDark\nGSColorComponent\nGSColorComponentLocked\nGSColorComponentAligned\nGSColorComponentHorizontalAligned\nGSColorComponentDark\nGSColorComponentLockedDark\nGSColorComponentAlignedDark\nGSColorComponentHorizontalAlignedDark\nGSColorForeground\nGSColorForegroundDark\nGSColorGridMain\nGSColorGridMainDark\nGSColorGridSub\nGSColorGridSubDark\nGSColorKerningNegative\nGSColorKerningNegativeDark\nGSColorKerningPositive\nGSColorKerningPositiveDark\nGSColorNodeCorner\nGSColorNodeCornerDark\nGSColorNodeSmooth\nGSColorNodeSmoothDark\nGSColorOtherLayersStroke\nGSColorOtherLayersStrokeDark\nGSColorZones\nGSColorZonesDark\n```\n\nThe ones that end in `Dark` are the variants for Dark Mode. Make sure you pick a more subdued, less screaming color, and brightness-wise, expect an inverted (white on black) environment. `GSColorForeground` and `GSColorForegroundDark` are (a) the colors of the paths while being edited, as well as (b) the fill color of the glyphs when you are typing with the Text tool (shortcut T). I think all the others are pretty self-explanatory.\n\nFor reporter plug-ins, we added a drawing API for Font View cells\n\n```\nself.drawFontViewBackgroundForLayer_inFrame_(layer, frame)\nself.drawFontViewForegroundForLayer_inFrame_(layer, frame)\n```\n\n… where `frame` is the `NSRect` that represents the glyph cell. Use this as reference for any drawing you want to do in the cell (e.g. a dot or a symbol). `Foreground` and `Background` mean that you draw in front of or behind the image of the glyph.\n\nFor reference, I implemented it [in the Show Component Order plug-in](https://github.com/mekkablue/ShowComponentOrder/blob/17da2a1c176a6afd1b5d515b8685df471c6ac377/ShowComponentOrder.glyphsReporter/Contents/Resources/plugin.py#L64-L81), and [in the Show Export Status plug-in](https://github.com/mekkablue/ShowExportStatus/blob/cf23f2768cb50da6aeca97c32762c27c7d283228/ShowExportStatus.glyphsReporter/Contents/Resources/plugin.py#L46-L52). The former also contains a useful function called `fitLayerInFrame()`, which helps scale the content of the layer into the cell the same way Glyphs does it. Comes in handy if you want to draw over the shapes of the glyph. We are discussing a convenience function for the future.\n\nAnd we have something for drawing in the Preview area as well:\n\n```\nself.drawBackgroundInPreviewLayer_options_(layer, options)\nself.drawForegroundInPreviewLayer_options_(layer, options)\nself.needsExtraMainOutlineDrawingInPreviewLayer_(layer)\n```\n\nThe variants for `Background` and `Foreground` are, like above, for drawing in front or behind the main outline. The argument `options` is a `dict` passed to the function, containing two keys for now:\n\n*   `options[\"Scale\"]` is a `float` representing the scale factor, similar to `self.getScale()` elsewhere, but exclusively for the preview in question. Use this for line widths that need to stay the same on the screen, no matter what the user scales the preview to. E.g., `lineWidth = 1.0 / options[\"Scale\"]` always gives you one pixel thickness.\n*   `options[\"Black\"]` is a `bool` representing the inverse setting in the Preview area: `True` if it is white type on black background, `False` if it is black type on white background. You may want to choose different color depending on context.\n\nIf you add a `needsExtraMainOutlineDrawingInPreviewLayer_()` function to your reporter, and it returns `False`, then Glyphs will not draw anything and leave it all to you.\n\nMore scripting news:\n\n*   Plug-ins and modules are updated more aggressively, though still quietly in the background\n*   Added documentation for `GSPathSegment`\n*   Added `GSGradient` to python wrapper\n*   Fixed the `drawingTools` Python API\n*   Fixed `GSComponent.automaticAlignment`\n*   Fixed `GSFont.newTab()`, sorry about the issues you may have run into\n*   Fixed missing `countOfUserData`\n*   Fixed `GSBackgroundImage` wrapper\n*   Fixed `GSInstance.active`: it always gives you the updated value now\n*   `GSElement.orientation` allows accessing the clockwise or counterclockwise orientation of components\n*   Fixed setting `GSGlyph.color` to `None` for deleting the assigned glyph color\n*   Improved handling of external scripts\n*   Refactored the _Extrude_ filter so you can access its objects from within a script\n*   Glyphs is now much better at catching plug-in exceptions\n*   Improved memory usage of Python scripts\n\nAnd, last but not least, we cleaned up the code samples on [docu.glyphsapp.com](https://docu.glyphsapp.com/). Sorry for any inconvenience you may have had in recent weeks.\n```\n\n\n請逐步引導使用者完成這個功能，讓使用者在開發過程中能夠更好地進行測試和除錯。\n\n我要加入一個機制，當我輸入多個（檔案中已經包含的）字符時，可以在九宮格中顯示這些字符（需要排除中間字符，中間維持為顯示目前編輯中字符）。並且加入一個按鈕，可以將這些字符在預覽視圖中亂數排列。\n這裡需要額外考慮的是，如何處理輸入的數值，需要辨識輸入的字元是unicode還是字形名稱。\n\n我想將新加入的「多字符的亂數排列功能」和目前已經有的「單個字符（包括字符選擇器、unicode碼位、字符名稱...等等）的輸入功能」分開。\n\n請逐步引導我完成這個功能，讓我在開發過程中能夠更好地進行測試和除錯。\n\n```py NineBoxView/Nine Box View.glyphsPlugin/Contents/Resources/plugin.py\n# encoding: utf-8\n\n###########################################################################################################\n#\n#\n#    一般外掛\n#\n#    閱讀文檔：\n#    https://github.com/schriftgestalt/GlyphsSDK/tree/master/Python%20Templates/General%20Plugin\n#\n#\n###########################################################################################################\n\n\n# https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CocoaViewsGuide/SubclassingNSView/SubclassingNSView.html\n\n# 導入必要的模組\nimport objc\nfrom GlyphsApp import *\nfrom GlyphsApp.plugins import *\nfrom AppKit import NSColor, NSFont, NSAffineTransform, NSRectFill, NSView, NSBezierPath, NSWorkspace, NSClickGestureRecognizer, NSMagnificationGestureRecognizer\nfrom vanilla import FloatingWindow, Group, Button, EditText\nimport traceback  # 新增此行以便進行錯誤追蹤\n\n# 定義九宮格預覽視圖類別\nclass NineBoxPreviewView(NSView):\n\n    # 繪製視圖內容\n    def drawRect_(self, rect):\n        try:\n            # 設定背景顏色\n            if self.wrapper.plugin.darkMode:\n                NSColor.colorWithCalibratedRed_green_blue_alpha_(0, 0, 0, 1.0).set()\n            else:\n                NSColor.colorWithCalibratedRed_green_blue_alpha_(1.0, 1.0, 1.0, 1.0).set()\n            NSRectFill(rect)\n\n            # 檢查是否有選中的字符層\n            if not Glyphs.font or not Glyphs.font.selectedLayers:\n                return\n\n            # 獲取目前選中的字符層和字符\n            self.currentLayer = Glyphs.font.selectedLayers[0]\n            currentChar = self.currentLayer.parent.unicode\n            currentMaster = Glyphs.font.selectedFontMaster  # 定義 currentMaster\n\n\n            # 決定要搜尋的字符\n            if self.wrapper.plugin.w.searchField.get().strip() == \"\":\n                self.searchChar = currentChar\n            else:\n                self.searchChar = self.wrapper.plugin.lastChar or currentChar\n\n            # 獲取中心字符和搜尋字符\n            centerGlyph = self.currentLayer.parent\n            searchGlyph = Glyphs.font.glyphs[self.searchChar] if self.searchChar else centerGlyph\n\n            # 檢查 searchGlyph 是否為 None\n            if searchGlyph is None:\n                print(f\"Warning: No glyph found for '{self.searchChar}'. Using center glyph instead.\")\n                searchGlyph = centerGlyph\n\n            # 設定邊距和間距比例\n            MARGIN_RATIO = 0.07\n            SPACING_RATIO = 0.03\n\n            # 計算字符高度和邊距\n            self.cachedHeight = currentMaster.ascender - currentMaster.descender\n            MARGIN = min(rect.size.width, rect.size.height) * MARGIN_RATIO\n\n            # 計算字符寬度和間距\n            centerWidth = self.currentLayer.width\n            searchWidth = searchGlyph.layers[currentMaster.id].width if searchGlyph.layers[currentMaster.id] else centerWidth\n            SPACING = max(centerWidth, searchWidth) * SPACING_RATIO\n\n            # 計算單元格寬度\n            searchCellWidth = searchWidth + SPACING\n            centerCellWidth = max(centerWidth, searchWidth) + SPACING\n\n            # 計算網格總寬度和高度\n            gridWidth = centerCellWidth + 2 * searchCellWidth + 2 * SPACING\n            gridHeight = 3 * self.cachedHeight + 2 * SPACING\n\n            # 計算縮放比例\n            availableWidth = rect.size.width - 2 * MARGIN\n            availableHeight = rect.size.height - 2 * MARGIN\n            scale = min(availableWidth / gridWidth, availableHeight / gridHeight, 1)\n\n            # 應用自定義縮放\n            customScale = self.wrapper.plugin.zoomFactor\n            scale *= customScale\n\n            # 更新網格尺寸\n            centerCellWidth *= scale\n            searchCellWidth *= scale\n            gridWidth *= scale\n            gridHeight *= scale\n            SPACING *= scale\n\n            # 計算繪製起始位置\n            startX = rect.size.width / 2 - gridWidth / 2\n            offsetY = rect.size.height * 0.05\n            startY = (rect.size.height + gridHeight) / 2 + offsetY\n            leftColumnCenterX = startX + searchCellWidth / 2\n            middleColumnCenterX = startX + searchCellWidth + SPACING + centerCellWidth / 2\n            rightColumnCenterX = startX + gridWidth - searchCellWidth / 2\n\n            # 繪製九宮格中的字符\n            for i in range(9):\n                row = i // 3\n                col = i % 3\n                \n                # 決定目前單元格的中心位置和寬度\n                if col == 0:\n                    centerX = leftColumnCenterX\n                    cellWidth = searchCellWidth\n                elif col == 1:\n                    centerX = middleColumnCenterX\n                    cellWidth = centerCellWidth if i == 4 else searchCellWidth\n                else:\n                    centerX = rightColumnCenterX\n                    cellWidth = searchCellWidth\n                \n                centerY = startY - (row + 0.5) * (gridHeight / 3)\n                cellHeight = gridHeight / 3 - SPACING\n\n                # 選擇要繪製的字符層\n                if i == 4:\n                    layer = self.currentLayer\n                else:\n                    layer = searchGlyph.layers[currentMaster.id]\n\n                if layer:\n                    # 計算字符縮放比例\n                    glyphWidth = layer.width\n                    glyphHeight = self.cachedHeight\n                    scaleX = cellWidth / glyphWidth if glyphWidth > 0 else 1\n                    scaleY = cellHeight / glyphHeight if glyphHeight > 0 else 1\n                    glyphScale = min(scaleX, scaleY)\n\n                    # 計算縮放後的字符尺寸和位置\n                    scaledWidth = glyphWidth * glyphScale\n                    scaledHeight = glyphHeight * glyphScale\n                    x = centerX - scaledWidth / 2\n                    y = centerY - scaledHeight / 2\n\n                    # 建立變換矩陣\n                    transform = NSAffineTransform.transform()\n                    transform.translateXBy_yBy_(x, y)\n                    transform.scaleBy_(glyphScale)\n\n                    # 繪製字符路徑\n                    bezierPath = layer.completeBezierPath.copy()\n                    bezierPath.transformUsingAffineTransform_(transform)\n\n                    # 設定填充顏色\n                    if self.wrapper.plugin.darkMode:\n                        NSColor.whiteColor().set()\n                    else:\n                        NSColor.blackColor().set()\n                    bezierPath.fill()\n\n        except Exception as e:\n            print(traceback.format_exc())\n\n    # 處理滑鼠點擊事件\n    def mouseDown_(self, event):\n        # 當滑鼠在視圖內點擊時，使工具視窗成為關鍵視窗\n        self.window().makeKeyWindow()\n        self.window().makeFirstResponder_(self)\n\n# 定義九宮格預覽群組類別\nclass NineBoxPreview(Group):\n    nsViewClass = NineBoxPreviewView\n\n    def __init__(self, posSize, plugin):\n        super(NineBoxPreview, self).__init__(posSize)\n        self._nsObject.wrapper = self\n        self.plugin = plugin\n\n    def redraw(self):\n        self._nsObject.setNeedsDisplay_(True)\n\n# 定義主外掛類別\nclass NineBoxView(GeneralPlugin):\n\n    @objc.python_method\n    def settings(self):\n        # 設定外掛名稱\n        self.name = Glyphs.localize({\n            'en': u'Nine Box Preview',\n            'zh-Hant': u'九宮格預覽',\n            'zh-Hans': u'九宫格预览',\n            'ja': u'九宮格プレビュー',\n            'ko': u'구궁격 미리보기',\n            'ar': u'معاينة المربعات التسعة',\n            'cs': u'Náhled devíti polí',\n            'de': u'Neun-Felder-Vorschau',\n            'es': u'Vista previa de nueve cuadros',\n            'fr': u'Aperçu en neuf cases',\n            'it': u'Anteprima a nove caselle',\n            'pt': u'Visualização em nove caixas',\n            'ru': u'Предпросмотр девяти ячеек',\n            'tr': u'Dokuz Kutu Önizleme'\n        })\n        self.loadPreferences()\n\n    @objc.python_method\n    def start(self):\n        try:\n            # 新增選單項\n            newMenuItem = NSMenuItem(self.name, self.toggleWindow_)\n            Glyphs.menu[WINDOW_MENU].append(newMenuItem)\n            \n            # 新增回調函數\n            Glyphs.addCallback(self.updateInterface, UPDATEINTERFACE)\n            Glyphs.addCallback(self.updateInterface, DOCUMENTACTIVATED)\n\n            # 新增應用程式啟動和停用的觀察者\n            NSWorkspace.sharedWorkspace().notificationCenter().addObserver_selector_name_object_(\n                self,\n                self.applicationActivated_,\n                \"NSWorkspaceDidActivateApplicationNotification\",\n                None\n            )\n            NSWorkspace.sharedWorkspace().notificationCenter().addObserver_selector_name_object_(\n                self,\n                self.applicationDeactivated_,\n                \"NSWorkspaceDidDeactivateApplicationNotification\",\n                None\n            )\n            \n            # 載入偏好設定並開啟視窗\n            self.loadPreferences()\n            self.w.open()\n            self.w.makeKey()\n        except:\n            self.logToMacroWindow(traceback.format_exc())\n\n    @objc.python_method\n    def pickGlyph(self, sender):\n        font = Glyphs.font\n        if not font:\n            return\n        \n        choice = PickGlyphs(\n            list(font.glyphs),\n            font.selectedFontMaster.id,\n            self.lastChar,\n            \"com.YinTzuYuan.NineBoxView.search\"\n        )\n        \n        if choice and choice[0]:\n            selected_glyph = choice[0][0]\n            # 如果字形有 Unicode 值，使用它；否則使用字形名稱\n            self.lastChar = selected_glyph.unicode or selected_glyph.name\n            self.w.searchField.set(self.lastChar)\n            self.savePreferences()\n            self.updateInterface(None)\n\n    @objc.python_method\n    def toggleWindow_(self, sender):\n        try:\n            if not hasattr(self, 'w') or self.w is None:\n                # 載入上次保存的窗口大小，如果沒有則使用預設值\n                defaultSize = (300, 340)\n                savedSize = Glyphs.defaults.get(\"com.YinTzuYuan.NineBoxView.windowSize\", defaultSize)\n                \n                self.w = FloatingWindow(savedSize, self.name, minSize=(200, 240),\n                                        autosaveName=\"com.YinTzuYuan.NineBoxView.mainwindow\")\n                self.w.preview = NineBoxPreview((0, 0, -0, -40), self)\n                \n                placeholder = Glyphs.localize({\n                    'en': u'Enter char or leave blank for current',\n                    'zh-Hant': u'輸入或留空顯示目前字符',\n                    'zh-Hans': u'输入或留空显示当前字符形',\n                    'ja': u'文字入力 (空欄で現在の文字)',\n                    'ko': u'문자 입력 또는 공백으로 현재 문자',\n                    'ar': u'أدخل حرفًا أو اتركه فارغًا للحالي',\n                    'cs': u'Zadejte znak nebo nechte prázdné pro aktuální',\n                    'de': u'Zeichen eingeben oder leer für aktuelles',\n                    'es': u'Ingrese carácter o deje en blanco para el actual',\n                    'fr': u\"Saisissez un caractère ou laissez vide pour l'actuel\",\n                    'it': u\"Inserisci carattere o lascia vuoto per l'attuale\",\n                    'pt': u'Digite caractere ou deixe em branco para o atual',\n                    'ru': u'Введите символ или оставьте пустым для текущего',\n                    'tr': u'Karakter girin veya mevcut için boş bırakın'\n                })\n                \n                self.w.searchField = EditText((10, -30, -140, 22), \n                                            placeholder=placeholder, \n                                            callback=self.searchFieldCallback)\n                self.w.searchField.set(self.lastChar)\n                \n                searchButtonTitle = Glyphs.localize({\n                    'en': u'Glyph Picker',\n                    'zh-Hant': u'字符選擇器',\n                    'zh-Hans': u'字符形选择器',\n                    'ja': u'グリフ選択ツール',\n                    'ko': u'글리프 선택기',\n                    'ar': u'أداة اختيار المحارف',\n                    'cs': u'Výběr glyfů',\n                    'de': u'Glyphenauswahl',\n                    'es': u'Selector de glifos',\n                    'fr': u'Sélecteur de glyphes',\n                    'it': u'Selettore di glifi',\n                    'pt': u'Seletor de glifos',\n                    'ru': u'Выбор глифа',\n                    'tr': u'Glif Seçici'\n                })\n                self.w.searchButton = Button((-130, -30, -70, 22), searchButtonTitle,\n                                            callback=self.pickGlyph)\n                \n                self.w.darkModeButton = Button((-60, -30, -10, 22), self.getDarkModeIcon(),\n                                            callback=self.darkModeCallback)\n                \n                self.w.bind(\"close\", self.windowClosed_)\n                self.w.bind(\"resize\", self.windowResized_)\n                self.w.open()\n\n            # 調整已存在的元素\n            self.adjustUIElements()\n\n            self.w.makeKey()\n            self.updateInterface(None)\n        except:\n            self.logToMacroWindow(traceback.format_exc())\n\n    @objc.python_method\n    def adjustUIElements(self):\n        # 計算按鈕文字的寬度\n        searchButtonTitle = Glyphs.localize({\n            'en': u'Glyph Picker',\n            'zh-Hant': u'字符選擇器',\n            'zh-Hans': u'字符形选择器',\n            'ja': u'グリフ選択ツール',\n            'ko': u'글리프 선택기',\n            'ar': u'أداة اختيار المحارف',\n            'cs': u'Výběr glyfů',\n            'de': u'Glyphenauswahl',\n            'es': u'Selector de glifos',\n            'fr': u'Sélecteur de glyphes',\n            'it': u'Selettore di glifi',\n            'pt': u'Seletor de glifos',\n            'ru': u'Выбор глифа',\n            'tr': u'Glif Seçici'\n        })\n        buttonFont = NSFont.systemFontOfSize_(NSFont.systemFontSize())\n        buttonWidth = NSString.stringWithString_(searchButtonTitle).sizeWithAttributes_({NSFontAttributeName: buttonFont}).width\n\n        # 設定最小和最大寬度\n        minButtonWidth = 80\n        maxButtonWidth = 150\n        buttonWidth = max(minButtonWidth, min(buttonWidth + 20, maxButtonWidth))  # 加 20 為左右邊距\n\n        # 獲取當前窗口寬度\n        currentSize = self.w.getPosSize()\n        windowWidth = currentSize[2]\n\n        # 調整搜索欄位位置和大小\n        searchFieldWidth = windowWidth - 20 - buttonWidth - 60 - 20  # 20 是左邊距，60 是深色模式按鈕寬度，20 是按鈕間距\n        self.w.searchField.setPosSize((10, -30, searchFieldWidth, 22))\n\n        # 調整按鈕位置和大小\n        buttonX = searchFieldWidth + 20\n        self.w.searchButton.setPosSize((buttonX, -30, buttonWidth + 10, 22))\n        self.w.searchButton.setTitle(searchButtonTitle)\n\n        # 調整深色模式按鈕位置\n        darkModeButtonX = buttonX + buttonWidth + 20\n        self.w.darkModeButton.setPosSize((darkModeButtonX, -30, -10, 22))\n\n    @objc.python_method\n    def windowResized_(self, sender):\n        # 當窗口大小改變時，保存新的大小\n        newSize = sender.getPosSize()\n        Glyphs.defaults[\"com.YinTzuYuan.NineBoxView.windowSize\"] = newSize\n        \n        # 調整UI元素以適應新的窗口大小\n        self.adjustUIElements()\n\n    @objc.python_method\n    def windowClosed_(self, sender):\n        # 當窗口關閉時，保存窗口大小\n        Glyphs.defaults[\"com.YinTzuYuan.NineBoxView.windowSize\"] = sender.getPosSize()\n        self.w = None\n\n    @objc.python_method\n    def getDarkModeIcon(self):\n        return \"◐\" if self.darkMode else \"◑\"\n\n    @objc.python_method\n    def loadPreferences(self):\n        # 載入使用者偏好設定\n        self.darkMode = Glyphs.defaults.get(\"com.YinTzuYuan.NineBoxView.darkMode\", False)\n        self.lastChar = Glyphs.defaults.get(\"com.YinTzuYuan.NineBoxView.lastChar\", \"\")\n        self.testMode = Glyphs.defaults.get(\"com.YinTzuYuan.NineBoxView.testMode\", False)\n        self.searchHistory = Glyphs.defaults.get(\"com.YinTzuYuan.NineBoxView.search\", \"\")\n        self.zoomFactor = Glyphs.defaults.get(\"com.YinTzuYuan.NineBoxView.zoomFactor\", 1.0)\n\n    @objc.python_method\n    def savePreferences(self):\n        # 儲存使用者偏好設定\n        Glyphs.defaults[\"com.YinTzuYuan.NineBoxView.darkMode\"] = self.darkMode\n        Glyphs.defaults[\"com.YinTzuYuan.NineBoxView.lastChar\"] = self.lastChar\n        Glyphs.defaults[\"com.YinTzuYuan.NineBoxView.testMode\"] = self.testMode\n        Glyphs.defaults[\"com.YinTzuYuan.NineBoxView.search\"] = self.searchHistory\n        Glyphs.defaults[\"com.YinTzuYuan.NineBoxView.zoomFactor\"] = self.zoomFactor\n\n    @objc.python_method\n    def logToMacroWindow(self, message):\n        # 將訊息記錄到巨集視窗\n        Glyphs.clearLog()\n        print(message)\n\n    @objc.python_method\n    def updateInterface(self, sender):\n        # 更新介面\n        if hasattr(self, 'w') and self.w is not None and hasattr(self.w, 'preview'):\n            self.w.preview.redraw()\n\n    @objc.python_method\n    def searchFieldCallback(self, sender):\n        char = sender.get().strip()\n        if char:\n            glyph = Glyphs.font.glyphs[char]\n            if glyph:\n                self.lastChar = char\n            else:\n                print(f\"Warning: No glyph found for '{char}'. Using previous character.\")\n        else:\n            self.lastChar = \"\"\n        sender.set(self.lastChar)\n        self.savePreferences()\n        self.updateInterface(None)\n\n    @objc.python_method\n    def darkModeCallback(self, sender):\n        # 切換深色模式\n        self.darkMode = not self.darkMode\n        sender.setTitle(self.getDarkModeIcon())\n        self.savePreferences()\n        self.updateInterface(None)\n\n    @objc.python_method\n    def resetZoom(self):\n        # 重置縮放\n        self.zoomFactor = 1.0\n        self.savePreferences()\n        self.updateInterface(None)\n\n    @objc.python_method\n    def showWindow(self):\n        # 顯示視窗\n        if hasattr(self, 'w') and self.w is not None:\n            self.w.show()\n\n    @objc.python_method\n    def hideWindow(self):\n        # 隱藏視窗\n        if hasattr(self, 'w') and self.w is not None:\n            self.w.hide()\n\n    @objc.python_method\n    def __del__(self):\n        # 清理資源\n        self.savePreferences()\n        Glyphs.removeCallback(self.updateInterface, UPDATEINTERFACE)\n        Glyphs.removeCallback(self.updateInterface, DOCUMENTACTIVATED)\n        NSWorkspace.sharedWorkspace().notificationCenter().removeObserver_(self)\n\n    def __file__(self):\n        return __file__\n```\n\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"system","status":"Done","timestamp":{"replica_id":0,"value":3829}}},{"id":{"replica_id":0,"value":52},"start":26959,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3830}}}],"summary":"九宮格預覽外掛 - 限制文字輸入欄位區塊","slash_command_output_sections":[{"range":{"start":0,"end":14786},"icon":"Library","label":"Default","metadata":null},{"range":{"start":1,"end":1181},"icon":"Library","label":"Default","metadata":null},{"range":{"start":2,"end":253},"icon":"Library","label":"通用設定","metadata":null},{"range":{"start":254,"end":1037},"icon":"Library","label":"翻譯指南","metadata":null},{"range":{"start":1182,"end":14785},"icon":"Library","label":"思考 Claude","metadata":null},{"range":{"start":14788,"end":15049},"icon":"Library","label":"Python 開發指南","metadata":null},{"range":{"start":15115,"end":26841},"icon":"File","label":"NineBoxView/typings/glyphs-3-2-released.md","metadata":{"path":"NineBoxView/typings/glyphs-3-2-released.md"}},{"range":{"start":27661,"end":46947},"icon":"File","label":"NineBoxView/Nine Box View.glyphsPlugin/Contents/Resources/plugin.py","metadata":{"path":"NineBoxView/Nine Box View.glyphsPlugin/Contents/Resources/plugin.py"}}]}